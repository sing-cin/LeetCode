## [581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/)

#双指针

1.题意

    1）给定整数数组nums，找出最短连续子数组，若对其排序则整个数组即可变为升序排序。返回最短子数组长度。进阶：时间复杂度为O(n)。

    2）nums.length[1, 10E4]，数组元素[-10E5, 10E5]。

2.示例

    1）输入：nums = [2,6,4,8,10,9,15]，输出：5

    2）输入：nums = [1,2,3,4]，输出：0

    3）输入：nums = [1]，输出：0。

## 解法一: 动态规划 + 双指针·『自己所想』

    ①整个数组索引为[0~n-1]分为三部分: 已有序部分A + 待排序部分B + 已有序部分C。
        其中有序部分A任一位置 满足: nums[index] = min(nums[index~n-1]), 即当前位置元素，是后续所有元素的最小值。
        其中有序部分C任一位置 满足: nums[index] = max(nums[0~index])，  即当前位置元素，是之前的所有元素的最大值。

    ②定义两数组，int[n] maxNum, int[n] minNum：
        minNum[i] = nums[i,n-1]范围内最小值
        maxNum[i] = nums[0, i ]范围内最大值
    利用动态规划计算两数组。

    ③假如 有序部分A某元素索引left，必满足nums[left] = minNum[left]
    从左向右遍历，直至找到边界位置left。
    同理，找到另一边界right。

    ④left、right边界位置确定，即确定待排序部分长度。

2.代码
```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length;

        int[] minNum =  new int[n]; // minNum[i] = nums[i,n-1]范围内最小值
        int[] maxNum = new int[n];  // maxNum[i] = nums[0,i  ]范围内最大值


        minNum[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            minNum[i] = Math.min(minNum[i + 1], nums[i]);
        }

        maxNum[0] = nums[0];
        for (int i = 1; i < n; i++) {
            maxNum[i] = Math.max(maxNum[i - 1], nums[i]);
        }

        int left = 0;
        int right = n-1;

        while (left < n && nums[left] == minNum[left]) {
            left++;
        }

        //这里用left < right 代替 0<right, 可使left=n即全局有序时免于计算右边界right
        while (left < right && nums[right] == maxNum[right]) {
            right --;
        }
        return left < right ? right - left + 1 : 0;
    }
}
```

3.复杂度

    ①时：O(n)

    ②空：O(n)

## todo:空间优化
    如: 考虑两数组可复用同一数组空间。


## 解法二：LeetCode官方题解·一次遍历

    ①同解法一。将原数组nums分为三个子部分：已有序部分A + 待排序部分B + 已有序部分C。
        转换为求 B段索引边界[left, right]。

    ②寻找right。
    从左->右 遍历数组，维护最大值max；即进入C段后，遍历到元素应该均满足 max[0~index) <= 段C元素nums[index]。
    那么该遍历过程中，记录最后一个不满足如上不等式的索引位置，即为段B右边界right。

    ③同理，寻找left。
    从右->左 遍历数组，维护最小值min；即进入A段后，遍历到元素应该均满足 段A元素nums[index] <= min(index~n-1]。
    那么该遍历过程中，记录最后一个不满足如上不等式的索引位置，即为段B左边界left。

    ④注意：数组本身有序情况，即len(numB) = 0;


2.代码
```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length;
        int maxValue = Integer.MIN_VALUE;
        int minValue = Integer.MAX_VALUE;
        int left = -1;
        int right = -1;


        // 从左→右遍历，寻找右边界right，即最后一个不满足maxNum <= num[i]的位置
        for (int i = 0; i < n; i ++) {
            if (maxValue <= nums[i]) {
                maxValue = nums[i];
            }
            else {
                right = i;
            }
        }

        // 从右→左遍历，寻找左边界left，即最后一个不满足num[i] <= minNum的位置
        for (int i = n - 1; i >= 0; i--) {
            if (nums[i] <= minValue) {
                minValue = nums[i];
            }
            else {
                left = i;
            }
        }

        //return right == -1 ? 0 : right - left + 1;
        return right == left ? 0 : right - left + 1;
    }
}
```

3.复杂度

    1）时：O(n)

    2）空：O(1)
