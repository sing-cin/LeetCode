## [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/)

#动态规划
#哈希表

1.题意

    1）给定整数数组nums，计算连续子数组和为整数k的个数。

    2）数组长度[1, 2*10E4]，元素[-1000, 1000]，k[-10E7, 10E7]。

2.示例

    1）输入：nums = [1,1,1], k = 2，输出：2

    2）输入：nums = [1,2,3], k = 3，输出：2。


## 解法零：滑动窗口·「不可行」

    1）数组元素可能为负数，双指针·滑动窗口策略不可行。

## 解法一: 暴力解法-双层for循环

1.思路解析

    ①dp[i][j]表示nums[i~j]内连续数组和，若值为k，则计数res++；
    ②不使用dp[][] 二维数组表示，而是使用一个变量保存当前dp[i][j]值。


2.代码
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int res = 0;
        for (int right = 0; right < n; right++) {
            int preSum = 0;
            for (int left = right; left >= 0; left--) {
                preSum += nums[left];
                if (preSum == k) {
                    res++;
                }
            }
        }
        return res;
    }
}
```

3.复杂度

    1）时：O(n ^ 2)

    2）空：O(n^2)-->O(1)


## 解析二：动态规划
1.思路解析

    1）int[] dp = new int[n + 1]，dp[i]代表nums前i个元素累加和；int count代表所求结果。

    2）外循环i = 1~n，计算dp[i]；内循环j = 0~i-1。判断dp[j] + k = dp[i]的个数，并累计到count中。

2.代码
```java
//动态规划
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int[] dp = new int[n + 1];
        int count = 0;

        for (int i = 1; i <= n; i ++) {
            dp[i] = dp[i - 1] + nums[i - 1];
            for (int j = 0; j < i; j ++) {
                if (dp[j] + k == dp[i]) {
                    count ++;
                }
            }
        }
        return count;
    }
}
```

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int res = 0;
        for (int right = 0; right < n; right++) {
            int preSum = 0;
            for (int left = right; left >= 0; left--) {
                preSum += nums[left];
                if (preSum == k) {
                    res++;
                }
            }
        }
        return res;
    }
}
```
3.复杂度

    1）时：O(n ^ 2)

    2）空：O(n)

## 解法三：动态规划·优化：+ 记忆化搜索
1.思路解析

    1）在动态规划的基础上进行优化。利用哈希表Map<Integer, Integer>保存动态规划内层循环中dp[j]出现的次数，直接搜索map.getOrDegfault(dp[i] - k, 0)、并累加进count即可。

    2）空间优化：dp[i]可由dp[i-1]推出，可由一变量代替。

2.代码
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int[] dp = new int[n + 1];
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int count = 0;
      
        for (int i = 1; i <= n; i ++) {
            dp[i] = dp[i - 1] + nums[i - 1];
            count += map.getOrDefault(dp[i] - k, 0);
            int value = map.getOrDefault(dp[i], 0) + 1;
            map.put(dp[i], value);
        }
        return count;
    }
}
```
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int curSum = 0;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int count = 0;

        for (int i = 1; i <= n; i ++) {
            curSum += nums[i - 1];
            count += map.getOrDefault(curSum - k, 0);
            int value = map.getOrDefault(curSum, 0) + 1;
            map.put(curSum, value);
        }
        return count;
    }
}
```
3.复杂度

    1）时：O(n)

    2）空：O(n)→O(1)。