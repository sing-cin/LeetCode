## [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

#### #哈希表-Set
1.题意

    1）给定未排序数组nums，找出数字连续最长序列的长度，不要求序列元素在原数组中连续。要求：时间复杂度为O(n)。

    2）数组长度[0, 10E5]，元素[-10E9, 10E9]。

2.示例

    1）输入：nums = [100,4,200,1,3,2]，输出：4

    2）输入：nums = [0,3,7,2,5,8,4,6,0,1]，输出：9。

## 解法一：Set + 哈希表 · 记录左右边界·{自己所想}
1.思路解析·{两次遍历数组}

    ①遍历数组，利用hash表保存已遍历部分的边界。遍历至新元素后，更新左边界、右边界。

    ②示例。如nums = [10, 4, 20, 1, 2, {9}, 3]；遍历至9时，保存内容为{10, 10}, {4, 4}, {20, 20}, {1, 2}, {9, 9}

    ③遍历新元素num时，需考虑向左、右两侧分别寻找新边界 (xxx, num-1)、(num+1, xxx)。
    为方便计，需用2个map对象，二者均存储全部已遍历内容，但区别是一个以左边界为key、一个以右边界为key。

    ④遍历完后，map中保存的 max([left, right])---即为所求值。
    注意：当数组中存在重复元素时，遍历时会干扰正确值计算。为此需实现用Set去重。

2.代码
```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }
        Map<Integer, Integer> leftMap = new HashMap<>();
        Map<Integer, Integer> rightMap = new HashMap<>();
        int maxLen = 0;
        for (int num : nums) {
            int curLen = addNum(leftMap, rightMap, num);
            maxLen = Math.max(maxLen, curLen);
        }
        return maxLen;
    }

    private int addNum(Map<Integer, Integer> leftKeyMap, Map<Integer, Integer> rightKeyMap, int num) {
        int rightNum = leftKeyMap.getOrDefault(num + 1, num);
        int leftNum = rightKeyMap.getOrDefault(num - 1, num);


        if (rightNum != num) {
            leftKeyMap.remove(num + 1);
            // rightKeyMap.remove(rightNum);
        }
        if (leftNum != num) {
            // leftKeyMap.remove(leftNum);
            rightKeyMap.remove(num - 1);
        }

        leftKeyMap.put(leftNum, rightNum);
        rightKeyMap.put(rightNum, leftNum);
        int curLength = rightNum - leftNum + 1;
        return curLength;
    }
}
```

3.复杂度

    1）时：O(n)

    2）空：O(n)


## 解法二: Set·优化·{官方解}
1.解析：哈希表。{一次遍历数组}
    
    ①解法一中已事先用set去重了数组。考虑直接用set做计算，而无需再使用hash表

    ②遍历set，假如有[left... middle - 1, middle, middle + 1... right]:
        当遇到非左边界值时，一律忽略；(对遍历值num，当set中含有num-1时，说明num不是最左边界)
        我们只有在遇到左边界值left时，触发遍历整条连续链，计算链条长度。

    ③返回最长链条长度即可。

2.代码
```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }
        int maxLen = 0;
        for (int num : set) {
            if (set.contains(num - 1)) {
                continue;
            }
            int curLen = 0;
            int curNum = num;
            while (set.contains(curNum)) {
                curLen ++;
                curNum ++;
            }
            maxLen = Math.max(maxLen, curLen);
        }
        return maxLen;
    }
}
```
3.复杂度

    1）时：O(n)

    2）空：O(n)
