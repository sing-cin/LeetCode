### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)

#### #贪心
1.题意

    1）给定整数数组prices，元素代表每天股票价格。允许进行一次交易(买入股票一次，后续卖出股票一次)，计算可得最大利润（未获利返回0）

    2）数组长度[1,10^5],元素[0,10^4]。

2.示例

    1）输入：[7,1,5,3,6,4]，输出：5

    2）输入：prices = [7,6,4,3,1]，输出：0。
## 解法一：动态规划
1.解析

    1）int dp[n]。其中dp[i]表示第i天售出所能获得的最大收益。则dp[i] = prices[i] - min(prices[j],0≤j≤i)；最终结果返回max(dp[i], 0≤i＜n)即可

2.1 Java代码(可行)
```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[] dp = new int[n];
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        for (int i = 0; i < n; i ++) {
            minPrice = Math.min(minPrice, prices[i]);
            dp[i] = prices[i] - minPrice;
            maxProfit = Math.max(maxProfit, dp[i]);
        }
        return maxProfit;
    }
}
```

2.2 Java代码(不可行)

    ①有动态规划数组：int dp[n][2]。其中dp[i][0]表示第i天不持有股票的最大收益，dp[i][1]表示第i天持有股票的最大收益
    ②状态转移方程：
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
    
    ③边界条件：dp[0][0]=-prices[0]，dp[0][1]=0.  
        for循环计算完毕时，返回max(dp[n-1][0], dp[n-1][1])=dp[n-1][1]，因为若想获得最大收益，最后一次必定不持有股票
        
    ④不可行原因：这实际代表的是支持多次买入卖出，而非题意要求的仅一次买入卖出
        对输入prices=[7,1,5,3,6,4]，最大收益交易为[购入1， 卖出5， 购入3，卖出6]=7
        满足题意实际最大收益[购入1，卖出6]=5


```java
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        std::vector<std::vector<int>> dp(n, std::vector<int>(2));
        dp[0][0] = -prices[0]; // 持有
        dp[0][1] = 0; // 非持有

        for (int i = 1; i < n; i++) {
            dp[i][0] = std::max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = std::max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
        }
        return dp[n - 1][1];
    }
};
```

3.复杂度

    1）时：O(n)

    2）空：O(n)

## 解法二：复杂度优化版--贪心
1.解析

    1）遍历数组至元素prices[i]时，若选择当日卖出股票，则要获利最大、需在[0,i-1]天内股票价最低时买入，计本日卖出可获利最大为profit[i]。遍历数组结束后，返回最大profit即可.

2.Java代码
```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int minPrice = Integer.MAX_VALUE;
        int curProfit = 0;
        int maxProfit = 0;
        for (int i = 0; i < n; i ++) {
            minPrice = Math.min(minPrice, prices[i]);
            curProfit = prices[i] - minPrice;
            maxProfit = Math.max(maxProfit, curProfit);
        }
        return maxProfit;
    }
}
```

3.C++代码
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int minPrice = prices[0];
        int maxProfit = 0;

        for (int i = 1; i < n; i++) {
            minPrice = std::min(minPrice, prices[i]);
            maxProfit = std::max(maxProfit, prices[i] - minPrice);
        }
        return maxProfit;
    }
};
```

4.复杂度

    1）时：O(n)

    2）空：O(1)
