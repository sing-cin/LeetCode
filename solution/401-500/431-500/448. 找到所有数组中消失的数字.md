## [448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/)

#### #数组
1.题意

    1）给定含n个整数的数组nums，元素范围[1, n]。找出所有[1, n]范围内、且未出现在数组nums中的数字。

    2）进阶：时间复杂度O(n)，空间复杂度O(1)、原地置换，返回数组不算在额外空间中。

    3）n[1, 10E5]，元素[1, n]。

2.示例

    1）输入：nums = [4,3,2,7,8,2,3,1]，输出：[5,6]

    2）输入：nums = [1,1]，输出：[2]。

## 解法一：位置交换排序·{自己所想}
1.思路解析

    ①[0~n-1]索引位置上对应[1~n]元素，遍历数组交换元素排序。

    ②遍历结束后位置i不符对应关系的，i+1即为缺失元素。

    ③缺点: 会改变原数组内容，且无法复原。

2.代码

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            // 跳出循环条件1：当前位置存放元素·符合要求
            // 跳出循环条件2：当前位置元素、与待互换位置元素相同。(若不打破将死循环)
            while (i + 1 != nums[i] && nums[i] != nums[nums[i] - 1]) {
                swap(nums, i, nums[i] - 1);
            }
        }

        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (i + 1 != nums[i]) {
                res.add(i + 1);
            }
        }
        return res;
    }

    private void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
```

3.复杂度

    1）时：O(N * N)

    2）空：O(1)


## 解法二：利用原数组记录缺失数字·{官方解法}
1.思路解析

    ①一个很自然想法是：利用第三方(如Map、Set)存储出现数字，最后遍历第三方对象找出缺失数字。
    优化：考虑将用第三方对象标记出现数字，转换为利用原数组本身标记。空间复杂度：O(N) → O(1)

    ②遍历数组，遍历过程中将nums[i]-1指定位置自增n；
    后续再遍历数组时，若发现该位置元素nums[index]在[1, n]范围内，说明原数组未出现 index+1 数字使该位置增加，即该数字缺失。

    ③该算法效率更优。注意：记录后将数组还原。


2.代码
```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        // 记录缺失数字
        for (int i = 0; i < n; i ++) {
            int index = (nums[i] - 1) % n;
            nums[index] += n;
        }
        
        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < n; i ++) {
            // 记录缺失元素
            if (nums[i] <= n) {
                res.add(i + 1);
            }
            // 恢复原数组
            else {
                nums[i] = (nums[i] - 1) % n + 1;
                //nums[i] = nums[i] % n == 0 ? n : nums[i] % n; 
            }
        }
        return res;
    }
}
```

3.复杂度

    1）时：O(n)

    2）空：O(1)