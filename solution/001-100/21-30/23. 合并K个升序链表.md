## [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

#### #分治-归并排序 #链表
1.题意

    给定一链表数组，里面各链表已升序排列；将所有链表合并为一个升序链表返回

2.示例

    1）输入：lists = [[1,4,5],[1,3,4],[2,6]]; 输出：[1,1,2,3,4,4,5,6]
    2）输入：lists = [];   输出：[]
    3）输入：lists = [[]]; 输出：[]


### 解法：递归 + 归并排序
1.解析

    1) 将原函数重载为带起/止下标函数：mergeKLists(lists, left, right)
    2) 初始时，起止范围涵盖整个链表数组，即：int left = 0;int right = lists.size() - 1
    3) 递归分治：mergeKLists(lists, left, right) → mergeKLists(lists, left, middle) + mergeKLists(lists, middle + 1, right)；即转换为两个更小的有序子链表，为效率计，两个子链尽可能均分，即middle = (left + right) / 2
    4) 收尾：合并两个有序链表。

2.Java代码
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) {
            return null;
        }
        return mergeKLists(lists, 0, lists.length - 1);
    }

    private ListNode mergeKLists(ListNode[] lists, int left, int right) {
        if (left == right) {
            return lists[left];
        }
        int mid = (left + right) / 2;
        ListNode head1 = mergeKLists(lists, left, mid);
        ListNode head2 = mergeKLists(lists, mid + 1, right);
        return mergeLists(head1, head2);
    }

    private ListNode mergeLists(ListNode head1, ListNode head2) {
        ListNode dummyHead = new ListNode(-1);
        ListNode preNode = dummyHead;
        ListNode curNode1 = head1;
        ListNode curNode2 = head2;
        while (curNode1 != null && curNode2 != null) {
            if (curNode1.val < curNode2.val) {
                preNode.next = curNode1;
                curNode1 = curNode1.next;
            } else {
                preNode.next = curNode2;
                curNode2 = curNode2.next;
            }
            preNode = preNode.next;
        }
        preNode.next = curNode1 != null ? curNode1 : curNode2;
        return dummyHead.next;
    }


}
```

3.C++代码
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() == 0) {
            return nullptr;
        }
        return mergeKLists(lists, 0, lists.size() - 1);
    }

    ListNode* mergeKLists(vector<ListNode*>& lists, int left, int right) {
        if (left == right) {
            return lists[left];
        }
        int middle = (left + right) / 2;
        ListNode* head1 = mergeKLists(lists, left, middle);
        ListNode* head2 = mergeKLists(lists, middle + 1, right);
        return mergeLists(head1, head2);
    }

    // 虚拟头节点--new方式
    ListNode* mergeLists(ListNode* head1, ListNode* head2) {
        ListNode* dummyHead = new ListNode();
        ListNode* preNode = dummyHead;
        while (head1 != nullptr && head2 != nullptr) {
            if (head1->val < head2->val) {
                preNode->next = head1;
                head1 = head1->next;
            } else {
                preNode->next = head2;
                head2 = head2->next;
            }
            preNode = preNode->next;
        }
        preNode->next = (head1 != nullptr ? head1 : head2);

        ListNode* newHead = dummyHead->next;
        // dummyHead->next = nullptr; // 直接delete即可，无需先断连接
        delete dummyHead; // 手动delete释放内存，避免内存泄漏，风格更好 (LeetCode 环境可能不需要)

        return newHead;
    }

    // 虚拟头结点--栈方式 (更推荐)
    ListNode* mergeLists2(ListNode* head1, ListNode* head2) {
        ListNode dummyHead;
        ListNode* preNode = &dummyHead;
        while (head1 != nullptr && head2 != nullptr) {
            if (head1->val < head2->val) {
                preNode->next = head1;
                head1 = head1->next;
            } else {
                preNode->next = head2;
                head2 = head2->next;
            }
            preNode = preNode->next;
        }
        preNode->next = (head1 != nullptr ? head1 : head2);
        return dummyHead.next; // 直接返回即可；栈对象自动回收、无需delete
    }

};
```

4.复杂度

    1）时：O(n * klogK) --n为单个链表平均长度，k为链表个数/数组大小

    2）空：O(logK) --递归栈空间
