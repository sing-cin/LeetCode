## [15. 三数之和](https://leetcode.cn/problems/3sum/)

#### #数组 #双指针
1.题意

    1）给定一整数数组nums，判断是否存在三元素a、b、c,使得其和为0.返回所有这样的不重复组合。

    2）数组长度[0,3000],元素取值[-10^5,10^5].

2.示例

    1）输入：nums = [-1,0,1,2,-1,-4]，输出：[[-1,-1,2],[-1,0,1]]

    2）输入：nums = []，输出：[]

    3）输入：nums = [0]，输出：[]。
## 解析: 双指针
1.解析

    1）将nums排序，三指针i、left、right分别指向三元素。遍历数组，指针i[0-->n-3]遍历，left、right分别位于[i+1， n-1]向内部遍历。判断三元素和是否为0.

    2）注意判断：去除重复元素。nums[i] = nums[i - 1],nums[left] = nums[left - 1],nums[right] = nums[right + 1j]均需排除，另外nums[i] >0时直接退出循环即可。

2.Java代码
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i <= n - 3; i ++) {
            if (nums[i] + nums[i + 1] + nums[i + 2] > 0) {
                break;
            }
            if (nums[i] + nums[n - 2] + nums[n - 1] < 0) {
                continue;
            }
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = n - 1;
            while (left < right) {
                // if (nums[i] + nums[left] + nums[left + 1] > 0) {
                //     break;
                // }
                // if (nums[i] + nums[right - 1] + nums[right] < 0) {
                //     break;
                // }
                if (left > i + 1 && nums[left] == nums[left - 1]) {
                    left ++;
                    continue;
                }
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[left]);
                    list.add(nums[right]);
                    res.add(list);
                    left ++;
                    right --;
                }
                else if (sum < 0) {
                    left ++;
                }
                else {
                    right --;
                }
            }
        }
        return res;    
    }
}   
```

3.C++代码
```c++
// 暴力解法: 3重for循环遍历, O(n^3)
// 注释代码为剪枝优化部分，剪枝优化前仅能通过部分case, 剪枝优化后能通过99.99%的case
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        // int maxNum = INT_MIN;
        // int minNum = INT_MAX;
        // for (int num : nums) {
        //     maxNum = std::max(maxNum, num);
        //     minNum = std::min(minNum, num);
        // }
        // if (maxNum < 0 || minNum > 0) {
        //     return res;
        // }

        std::sort(nums.begin(), nums.end());
        int n = nums.size();
        for (int i = 0; i <= n - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            // if (nums[i] + nums[i + 1] + nums[i + 2] > 0) {
            //     break;
            // }
            // if (nums[i] + nums[n - 2] + nums[n - 1] < 0) {
            //     continue;
            // }
            for (int j = i + 1; j <= n - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                // if (nums[i] + nums[j] + nums[j + 1] > 0) {
                //     break;
                // }
                // if (nums[i] + nums[n - 2] + nums[n - 1] < 0) {
                //     continue;
                // }
                for (int k = j + 1; k <= n - 1; k++) {
                    // if (k > j + 1 && nums[k] == nums[k - 1]) {
                    //     continue;
                    // }
                    int sum = nums[i] + nums[j] + nums[k];
                    if (sum == 0) {
                        vector<int> vec = {nums[i], nums[j], nums[k]};
                        res.push_back(vec);
                        break;
                    }
                    if (sum > 0) {
                        break;
                    }
                }
            }
        }
        return res;
    }
};
```

```c++
// 最优解法: 外层for循环 + 内层左右双指针遍历, O(n^2)
// 注释代码处为剪枝优化版本的代码
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        // int maxNum = INT_MIN;
        // int minNum = INT_MAX;
        // for (int num : nums) {
        //     maxNum = std::max(maxNum, num);
        //     minNum = std::min(minNum, num);
        // }
        // if (maxNum < 0 || minNum > 0) {
        //     return res;
        // }

        std::sort(nums.begin(), nums.end());
        int n = nums.size();
        for (int i = 0; i <= n - 3; i++) {
            // if (nums[i] + nums[i + 1] + nums[i + 2] > 0) {
            //     break;
            // }
            // if (nums[i] + nums[n - 2] + nums[n - 1] < 0) {
            //     continue;
            // }
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = n - 1;
            while (left < right) {
                // if (nums[i] + nums[left] + nums[left + 1] > 0) {
                //     break;
                // }
                // if (nums[i] + nums[right - 1] + nums[right] < 0) {
                //     break;
                // }
                if (left > i + 1 && nums[left] == nums[left - 1]) {
                    left++;
                    continue;
                }
                if (right < n - 1 && nums[right] == nums[right + 1]) {
                    right--;
                    continue;
                }
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    std::vector<int> vec = {nums[i], nums[left], nums[right]};
                    res.push_back(vec);
                    left++;
                    right--;
                } else if (sum > 0){
                    right--;
                } else {
                    left++;
                }
            }
        }
        return res;
    }
};
```

4.复杂度

    1）时：O(n*n)

    2）空：O(logN)-排序所需
