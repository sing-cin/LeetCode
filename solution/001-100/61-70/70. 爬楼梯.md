## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

#### #动态规划 #数学
1.题意

    1）爬楼梯每次可以爬1阶或2阶，求爬到n阶有多少种方法。

    2）n范围[1, 45]。

2.示例

    1）输入：n = 2，输出：2

    2）输入：n = 3，输出：3。
## 解法
1.解析：动态规划

    1）状态转移方程：dp[i]  = dp[i-1] + dp[i-2].

    2）优化：用单个参数代替一维数组，降低空间复杂度。

2. java代码
```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i ++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```
```java
class Solution {
    public int climbStairs(int n) {
        int pre1 = 1;
        int pre2 = 1;
        for (int i = 2; i <= n; i ++) {
            int cur = pre1 + pre2;
            pre1 = pre2;
            pre2 = cur;
        }
        return pre2;  
    }
}
```

3. c++代码

①基础解法--动态规划（数组版）
```c++
class Solution {
public:
    int climbStairs(int n) {
        int dp[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

②基础解法--动态规划(std::vector)

    为什么不推荐int dp[n]?  int[] 是c99特性，不是现代c++标准 
    为什么不推荐std::array? 因std::array 长度需在编译时定长，而传参n需在运行时确定
```c++
class Solution {
public:
    int climbStairs(int n) {
        std::vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

③空间优化
```c++
class Solution {
public:
    int climbStairs(int n) {
        int pre_1 = 1;
        int pre_2 = 1;
        int temp;
        for (int i = 2; i <= n; i++) {
            temp = pre_1 + pre_2;
            pre_1 = pre_2;
            pre_2 = temp;
        }
        return pre_2;
    }
};
```

4.复杂度

    1）时：O(n)

    2）空：O(n)→O(1)

## 解法二: 数学