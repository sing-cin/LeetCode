## [02. 两数相加](https://leetcode.cn/problems/add-two-numbers/description/)
#### #链表
1.题意

    1）给定2非空单链表，表示2非负整数，每位数字按照逆序方式排列。计算2链表加和，以链表形式返回。

    2）链表均不含前导零。节点个数范围[1,100]，节点值范围[0,9]。

2.示例

    1）输入：l1 = [2,4,3], l2 = [5,6,4]，输出：[7,0,8]

    2）输入：l1 = [0], l2 = [0]，输出：[0]

    3）输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]，输出：[8,9,9,9,0,0,0,1].
![示例1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

    
## 题解
1.解析：遍历链表

    1）同步遍历2单链表，计算加和并创建新节点插入结果链表尾部。计算结束不要忽略是否新增一节点。

2.代码-Java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode cur1 = l1, cur2 = l2;
        int rest = 0;
        ListNode dummyHead = new ListNode(-1);
        ListNode pre = dummyHead;
        while (cur1 != null || cur2 != null) {
            int x = (cur1 == null ? 0 : cur1.val);
            int y = (cur2 == null ? 0 : cur2.val);
            int sum = x + y + rest;
            ListNode node = new ListNode(sum % 10);
            rest = sum / 10;
            pre.next = node;
            pre = node;
            if (cur1 != null) {
                cur1 = cur1.next;
            };
            if (cur2 != null) {
                cur2 = cur2.next;
            }
        }
        if (rest != 0) {
            pre.next = new ListNode(rest);
        }
        return dummyHead.next;
    }
}
```

3.代码-C++
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummyHead = new ListNode(-1);
        ListNode* curNode = dummyHead;
        int sum = 0;
        int carry = 0;
        while (l1 != nullptr || l2 != nullptr) {
            int num1 = l1 != nullptr ? l1->val : 0;
            int num2 = l2 != nullptr ? l2->val : 0;
            carry = rest + num1 + num2;
            curNode->next = new ListNode(sum % 10);
            carry = sum / 10;

            if (l1 != nullptr) {
                l1 = l1->next;
            }
            if (l2 != nullptr) {
                l2 = l2->next;
            }
            curNode = curNode->next;
        }
        if (carry != 0) {
            curNode->next = new ListNode(carry);
        }
        return dummyHead->next;
    }
};
```
②优化: 虚拟头节点改为栈内存分配，避免内存泄漏
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummyHead;
        ListNode* curNode = &dummyHead;
        int sum = 0;
        int carry = 0;
        while (l1 != nullptr || l2 != nullptr) {
            int num1 = l1 != nullptr ? l1->val : 0;
            int num2 = l2 != nullptr ? l2->val : 0;
            sum = carry + num1 + num2;
            curNode->next = new ListNode(sum % 10);
            carry = sum / 10;

            if (l1 != nullptr) {
                l1 = l1->next;
            }
            if (l2 != nullptr) {
                l2 = l2->next;
            }
            curNode = curNode->next;
        }
        if (carry != 0) {
            curNode->next = new ListNode(carry);
        }
        return dummyHead.next;
    }
};
```

4.复杂度

    1）时：O(max(m,n))-m、n为2链表长度。

    2）空：O(1)
