## [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/description/)

#### #双指针
1.题意

    1）给定n个非负整数，每个宽度为1的柱子高度图，求可接多少雨水。

    2）数组长度[1, 2*10E4]，数组元素[0,10E5]。

2.示例

    1）输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]，输出：6

    2）输入：height = [4,2,0,3,2,5]，输出：9。
![示例1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

## 解法一：单调栈·{自己所想}
1.思路解析

    ①当前柱子能承接雨水量 = min(柱子左侧最大高度, 柱子右侧最大高度) - 本柱子高度。即问题转化为：
    求当前柱子左侧最大高度、和当前柱子右侧最大高度。

    ②以求柱子右侧最大高度为例。
    从左->右遍历数组，构建递减单调栈，(为方便计，栈中元素为索引而非实际元素值)
    完成后，得到当前柱子i右侧第一个 {较高} 柱子索引，即higherInRight[i] = j。

    ③转换higherInRight数组为：当前柱子右侧 {最高} 柱子索引。
    即假如有如下递增链条：a→ b→ c→ d→ e→ f。
        原来:higherInRight[a] = b,higherInRight[b] = c。。。。higherInRight[f] = f;
        现在: heigherInRight[a、b、c...f] = f。
    为减少重复计算，遍历时可从右至左调整:
        若计算完c后: a→b→c→f
        再计算b: a→b→f   // 仅需计算一次。

    ④同理，可求得柱子左侧最大高度。
    在此基础上，即可得最大承接雨水量。

2.代码
```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int[] higherInRight = new int[n];
        int[] higherInLeft = new int[n];

        // 计算当前柱子i右侧第一个 {较高} 柱子索引
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            higherInRight[i] = i;
            while (!stack.isEmpty() && height[stack.peek()] < height[i]) {
                higherInRight[stack.pop()] = i;
            }
            stack.push(i);
        }

        stack.clear(); // 复用同一stack对象
        for (int i = n - 1; i >= 0; i--) {
            higherInLeft[i] = i;
            while (!stack.isEmpty() && height[stack.peek()] < height[i]) {
                higherInLeft[stack.pop()] = i;
            }
            stack.push(i);
        }

        // 计算当前柱子i {最高} 柱子索引
        for (int i = n - 1; i >= 0; i--) {
            if (higherInRight[i] != i) {
                higherInRight[i] = higherInRight[higherInRight[i]];
            }
        }

        for (int i = 0; i < n; i++) {
            if (higherInLeft[i] != i) {
                higherInLeft[i] = higherInLeft[higherInLeft[i]];
            }
        }

        int res = 0;
        for (int i = 0; i < n; i++) {
            int minHeight = Math.min(height[higherInLeft[i]], height[higherInRight[i]]);
            res += minHeight - height[i];
        }
        return res;
    }
}
```

3.复杂度

    1）时：O(n)

    2）空：O(n)


## 解法二: 双指针·{优化·官方解法}
1.思路解析

    ①同解法一。当前柱子容纳雨水量 = min(当前柱子左侧·最大高度, 当前柱子右侧最大高度) - 本柱子高度。即问题转化为：
    求当前柱子左侧·最大高度、和当前柱子右侧·最大高度。

    ②求柱子左侧·最大高度时，不必再使用单调栈（计算麻烦），而是直接一次遍历，经比较即可得当前柱子·左侧最大高度。

    ③可使用left、right双指针，双向逼近，遍历数组，得到当前柱子·左侧、右侧最大柱子高度。
    每次由left、right指针当前高度较小者移动，如maxLeftHeight < maxRightHeight，则left ++，同时记录该柱子容积。
        原因：只有较小者一侧移动，min(maxLeftHeight, maxRightHeight)才可能发生变化。
       

2.代码
```java
class Solution {
    public int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int leftMaxH = 0, rightMaxH = 0;
        int volume = 0;
        while (left <= right) {
            if (height[left] <= height[right]) {
                leftMaxH = Math.max(leftMaxH, height[left]);
                volume += leftMaxH - height[left];
                left ++;
            }
            else {
                rightMaxH = Math.max(rightMaxH, height[right]);
                volume += rightMaxH - height[right];
                right --;
            }
        }
        return volume;
    }
}
```
3.复杂度

    1）时：O(n)

    2）空：O(1)
