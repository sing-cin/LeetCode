## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)

#### #快排 #堆排序
1.题意

    1）给定int[] nums,int k,

    2）1 <= k <= nums.length <= 10E4，-10E4 <= nums[i] <= 10E4

2.要求

    1）返回数组中第k个最大元素（第k个最大元素，而非不同元素）

3.示例

    1）输入: [3,2,1,5,6,4] 和 k = 2

        输出: 5

    2）输入: [3,2,3,1,2,4,5,5,6] 和 k = 4

         输出: 4

## 解法一：快排
1.思路解析

    1）使用快排算法，每次确定索引为index元素位置，然后根据<index,k>大小关系使用递归。

2.1 代码
```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int n = nums.length;
        sort(nums, 0, n - 1, n - k);
        return nums[n - k];
    }

    private void sort(int[] nums, int left, int right, int k) {
        // if (left >= right) {
        //     return;
        // }
        int index = quickSort(nums, left, right);
        if (index == k) {
            return;
        } else if (index < k) {
            sort(nums, index + 1, right, k);
        } else {
            sort(nums, left, index - 1, k);
        }
    }
}
```

2.2 代码

    以下为代码下半部分。写法区别在于快排部分不同。
```java
    // 写法一: 原生·类快排写法·{自己所想}
    private int quickSort(int[] nums, int left, int right) {
        int beginIndex = left;
        int pivot = nums[left];

        while (left < right) {
            while (left < right && nums[right] >= pivot) {
                right--;
            }
            swap(nums, left, right);
            while (left < right && nums[left] <= pivot) {
                left++;
            }
            swap(nums, left, right);
        }
        return right;
    }

    private void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
```

```java
    // 写法二: 类快排写法·{严蔚敏版}
    // 该版主要避免了数据频繁交换的次数
    private int quickSort(int[] nums, int left, int right) {
        int beginIndex = left;
        int pivot = nums[left];

        while (left < right) {
            while (left < right && nums[right] >= pivot) {
                right--;
            }
            nums[left] = nums[right];
            while (left < right && nums[left] <= pivot) {
                left++;
            }
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        return right;
    }
```

```java
    //写法三: 类排序算法效率非常依赖于 基准值pivot 选取，如遇特殊测试用例，效率会退化至O(N*N)
    // 为此对基准值pivot选取进行优化:
        // 方案一: 随机
        //方案二: left、middle、right中位数选取·{推荐}

    // private static final Random random = new Random(System.currentTimeMillis());
   private int quickSort(int[] nums, int left, int right) {
    // 优化方式一: 随机
    // int randomIndex = left + random.nextInt(right - left + 1);
    // swap(nums, left, randomIndex);
       
       // 优化方式二: 中位数
    int middleIndex = getMiddleIndex(nums, left, (left + right) / 2, right);
    swap(nums, left, middleIndex);


    int beginIndex = left;
    int pivot = nums[left];

    while (left < right) {
        while (left < right && nums[right] >= pivot) {
            right--;
        }
        swap(nums, left, right);
        while (left < right && nums[left] <= pivot) {
            left++;
        }
        swap(nums, left, right);
    }
    return right;
}

private void swap(int[] nums, int left, int right) {
    int temp = nums[left];
    nums[left] = nums[right];
    nums[right] = temp;
}

private int getMiddleIndex(int[] nums, int index1, int index2, int index3) {
    // 获取三个索引对应的值
    int val1 = nums[index1];
    int val2 = nums[index2];
    int val3 = nums[index3];

    // 比较并确定中位数索引
    if ((val1 >= val2 && val1 <= val3) || (val1 <= val2 && val1 >= val3)) {
        return index1;
    } else if ((val2 >= val1 && val2 <= val3) || (val2 <= val1 && val2 >= val3)) {
        return index2;
    } else {
        return index3;
    }
}
```

3.复杂度

    1）时：O(n)--最差会劣化至O(N*N)；平均效率为O(N)--《算法导论》中推导

    2）空：O(logN)-递归栈


## 解法二：堆-优先队列
1.思路解析

    1）建立一个最小堆，保存数据流中最大k个数。对nums前k个数直接入堆;

    2) 后面数nums[i] > minHeap.peek()时，将nums[i]加入堆，并弹出一个数保持大小为k。

2.代码
```java
// 42ms; 击败41.30%
class Solution {
    public int findKthLargest(int[] nums, int k) {        
        int n = nums.length;
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);
        for (int i = 0; i < k; i ++) {
            minHeap.offer(nums[i]);
        }
        for (int i = k; i < n; i ++) {
            if (minHeap.peek() < nums[i]) {
                minHeap.poll();
                minHeap.offer(nums[i]);
            }
        }
        return minHeap.peek();
    }             
}
```
3.复杂度

    1）时：O(N * logK)-遍历n个数，每次调整logK

    2）空：O(k)-堆保存k个数

### todo: 手撕堆
    java中封装好了PriorityQueue，有些面试官（如字节）会问到如何实现堆，而不能直接使用PriorityQueue.