## [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

#### #栈 #递归
1.题意

    1）加码规则k[encoded_string]表示将字符串encoded_string重复整数k遍，给定加码后的String s，返回解码后的原始字符串。

    2）s长度[1, 30]，s组成元素{小写字母、数字、'['、']'}，k范围[1, 300]，s保证输入有效。

2.示例

    1）输入：s = "3[a]2[bc]"，输出："aaabcbc"

    2）输入：s = "3[a2[c]]"，输出："accaccacc"

    3）输入：s = "2[abc]3[cd]ef"，输出："abcabccdcdcdef"

    4）输入：s = "abc3[cd]xyz"，输出："abccdcdcdxyz"。

## 解法一：双栈--数字栈 + 字符栈
    1）Stack<Integer>numStack, Stack<Char>charStack分别保存数字、字符。遍历String s，对当前字符c：

            ①c为数字，累计算数字num。
            ②c为'['，代表字符即将出现。将num压入numStack，'['压入charStack作为标志位；
            ③c为字符'a'~'z'，直接压入charStack。
            ④c为']'，需要出栈。numStack弹出num，charStack依次弹出元素直至'['。拼接num段后依次压入charStack。

    2）s遍历结束后，numStack为空，charStack仅含'a'~'z'，将后者元素依次拼接返回即可。
2.代码
```java
class Solution {
    public String decodeString(String s) {
        int n = s.length();
        Stack<Character> charStack = new Stack<>();
        Stack<Integer> numStack = new Stack<>();
        int num = 0;
        
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (c >= '0' && c <= '9') {
                num = num * 10 + (c - '0');
            } else if (c == '[') {
                numStack.push(num);
                num = 0;
                charStack.push(c);
            } else if (c == ']') {
                help(charStack, numStack);
            } else {
                charStack.push(c);
            }
        }
        StringBuilder res = new StringBuilder();
        while (!charStack.isEmpty()) {
            res.append(charStack.pop());
        }
        return res.reverse().toString();
    }

    private void help(Stack<Character> charStack, Stack<Integer> numStack) {
        StringBuilder sb = new StringBuilder();
        while (charStack.peek() != '[') {
            sb.append(charStack.pop());
        }
        charStack.pop();
        int curNum = numStack.pop();
        for (int i = 0; i < curNum; i++) {
            for (int j = sb.length() - 1; j >= 0; j--) {
                charStack.push(sb.charAt(j));
            }
        }
    }
}
```

3.复杂度

    ①时：O(S + |s|)

    ②空：O(S)


## 解法二：双栈优化-数字栈 + 字符串栈
    1）优化思路一：对解法一中字符栈每次压入弹出单个字符，考虑：中间过程做处理后，将涉及字符拼接为字符串、作为整体压入charStack中。
    2）优化思路二：更近一步，取消'['标志位，所有操作均压入字符串。遍历String s，对当前字符c：

            ①c为数字，计算出现数字num。

            ②c为字符，暂存在StringBuilfer res中；

            ③c为'['，将数字num放入stack_num，字符串res放入stack_string。

            ④c为']'，res = (stack_string.pop() + stack_num * res)。

            ⑤遍历结束后，返回res.toString()即可。

2.代码
```java
class Solution {
    public String decodeString(String s) {
        int n = s.length();
        Deque<String> charStack = new LinkedList<>();
        Deque<Integer> numStack = new LinkedList<>();
        int num = 0;
        
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (c >= '0' && c <= '9') {
                num = num * 10 + (c - '0');
            } else if (c == '[') {
                numStack.push(num);
                num = 0;
                charStack.push(String.valueOf(c));
            } else if (c == ']') {
                help(charStack, numStack);
            } else {
                charStack.push(String.valueOf(c)); //todo:也可考虑StringBuilder先拼接再统一压入
            }
        }
        return join(charStack);
    }

    private String join(Deque<String> charStack) {
        StringBuilder res = new StringBuilder();
        while (!charStack.isEmpty()) {
            String curStr = charStack.pop();
            for (int i = curStr.length() - 1; i >= 0; i--) {
                res.append(curStr.charAt(i));
            }
        }
        return res.reverse().toString();
    } 

    private void help(Deque<String> charStack, Deque<Integer> numStack) {
        StringBuilder sb = new StringBuilder();
        while (!charStack.peek().equals("[")) {
            String curStr = charStack.pop();
            for (int i = curStr.length() - 1; i >= 0; i--) {
                sb.append(curStr.charAt(i));
            }
        }
        sb.reverse();
        charStack.pop();
        int curNum = numStack.pop();
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < curNum; i++) {
            res.append(sb);
        }
        charStack.push(res.toString());
    }
}
```

```java
class Solution {
    public String decodeString(String s) {
        StringBuilder res = new StringBuilder();
        int num = 0;
        Deque<Integer> stack_num = new LinkedList<>();
        Deque<String> stack_String = new LinkedList<>();
        for (Character c : s.toCharArray()) {
            if (c >= '0' && c <= '9') {
                num = num * 10 + (c - '0');
            }

            else if (c == '[') {
                stack_num.push(num);
                num = 0;
                stack_String.push(res.toString());
                res = new StringBuilder();
            }
            else if (c == ']') {
                StringBuilder temp = new StringBuilder();
                temp.append(stack_String.pop());

                int curNum = stack_num.pop();
                String str = res.toString();
                for (int i = 0; i < curNum; i ++) {
                    temp.append(str);
                }
                res = new StringBuilder(temp.toString());
            }

            else {
                res.append(c);
            }
        }
        return res.toString();
    }
}

```

3.复杂度

    1）时：O(S + |s|)，「S-原字符串长度; |s|-加码字符串长度」

    2）空：O(S)

## 解法三：递归

    1）1.递归。传参有(String s, int index)。从索引index开始遍历字符串，对当前元素c：

                ①为数字，计算num；

                ②为字符，维护一StringBuilder并记录；

                ③为'['，开启递归-返回String[2] res，元素分别为递归结果字符串、递归结束索引i；

                ④为']'，res数组插入结束索引i，终止遍历。

        2.递归结束：返回res。

    2）调用dfs(s, 0)，返回结果数组中首元素即可。

2.代码
```java
class Solution {
    public String decodeString(String s) {
        return dfs(s, 0)[0];
    }

    private String[] dfs(String s, int index) {
        StringBuilder sb = new StringBuilder();
        String[] res = new String[2];
        int num = 0;
        for (int i = index; i < s.length(); i ++) {
            char c = s.charAt(i);
            if (c >= '0' && c <= '9') {
                num = num * 10 + (c - '0');
            }
            else if (c == '[') {
                String[] temp = dfs(s, i + 1);
                for (int j = 0; j < num; j ++) {
                    sb.append(temp[0]);
                }
                num = 0;
                i = Integer.parseInt(temp[1]);
            }
            else if (c == ']') {
                res[1] = i + "";
                break;
            }
            else {
                sb.append(c);
            }
        }
        res[0] = sb.toString();
        return res;
    }
}
```

3.复杂度

    1）时：O(S+|s|) = O(S)

    2）空：O(|s|)--栈递归深度