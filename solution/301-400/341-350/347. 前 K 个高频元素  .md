## [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/)

#### #堆

本题相当于[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)的进阶版

1.题意

    1）给定整数数组nums，返回其中出现频率前k高的元素。顺序任意，题目保证结果唯一。进阶：时间复杂度优于O(NlogN).

    2）数组长度[1, 10E5]，k范围[1, 数组中不同元素个数]。

2.示例

    1）输入: nums = [1,1,1,2,2,3], k = 2，输出: [1,2]

    2）输入: nums = [1], k = 1，输出: [1]。

## 解法一：堆排序
1.思路解析

    1）用哈希表Map存储<数组元素num, 出现次数count>键值对。建立最小堆minHeap，存储数组int[] {num, count}，大小为k。

    2）遍历map中<num, count>键值对，前k对直接入堆。后面若当前count > minHeap堆顶元素中count，先出堆顶再入堆，否则忽略操作。

    3）最后将堆中num元素插入数组，返回即可。

2.代码
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            int count = map.getOrDefault(num, 0) + 1;
            map.put(num, count);
        }
        int[][] array = new int[map.size()][2];
        int index = 0;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            array[index][0] = entry.getKey();
            array[index][1] = entry.getValue();
            index ++;
        }
        
//        PriorityQueue<int[]> minHeap = new PriorityQueue<>(k, new Comparator<int[]>() {
//            @Override
//            public int compare(int[] nums1, int[] nums2) {
//                return nums1[1] - nums2[1];
//            }
//        });
        
        PriorityQueue<int[]> minHeap = new PriorityQueue<>(k, (o1, o2) -> o1[1] - o2[1]);
        
        for (int i = 0; i < k; i ++) {
            minHeap.offer(array[i]);
        }
        for (int i = k; i < array.length; i ++) {
            if (array[i][1] > minHeap.peek()[1]) {
                minHeap.poll();
                minHeap.offer(array[i]);
            }
        }


        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = minHeap.poll()[0];
        }
        return res;
    }
}
```
3.复杂度

    1）时：O(N * logK)

    2）空：O(n)--哈希表O(N) + 堆O(K) = O(N)


## 解法二: 快排
1.思路解析

    1）同理。先利用hash表统计<num, count>出现次数。

    2）对<num, count>进行排序，依count升序排序。采用快排算法。

    3）最后将排序后部分返回即可。

2.1 代码·前半段
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            int count = map.getOrDefault(num, 0) + 1;
            map.put(num, count);
        }
        int[][] array = new int[map.size()][2];
        int index = 0;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            array[index][0] = entry.getKey();
            array[index][1] = entry.getValue();
            index ++;
        }

        int n = array.length;
        sort(array, 0, n - 1, n - k);


        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = array[i + n - k ][0];
        }
        return res;
    }

    private void sort(int[][] array, int left, int right, int k) {
        int index = partition(array, left, right);
        if (index == k) {
            return;
        } else if (index < k) {
            sort(array, index + 1, right, k);
        } else {
            sort(array, left, index - 1, k);
        }
    }

    private void swap(int[][] array, int left, int right) {
        int[] temp = array[left];
        array[left] = array[right];
        array[right] = temp;
    }

    private int getMiddleIndex(int[][] array, int index1, int index2, int index3) {
        int value1 = array[index1][1];
        int value2 = array[index2][1];
        int value3 = array[index3][1];

        if ((value1 <= value2 && value1 >= value3) || (value1 <= value3 && value1 >= value2)) {
            return index1;
        } else if ((value2 <= value1 && value2 >= value3) || (value2 <= value3 && value2 >= value1)) {
            return index2;
        } else {
            return index3;
        }
    }
}
```

2.2 代码·后半段

```java
// 基本写法
    private int partition(int[][] array, int left, int right) {
        int middleIndex = getMiddleIndex(array, left, (left + right) / 2, right);
        swap(array, left, middleIndex);

        int num = array[left][0];
        int pivot = array[left][1];
        while (left < right) {
            while (left < right && array[right][1] >= pivot) {
                right--;
            }
            swap(array, left, right); //

            while (left < right && array[left][1] <= pivot) {
                left++;
            }
            swap(array, left, right); //
        }
        return left;
    }
```

```java
// 优化写法·错误示例
// 这种array[left] = array[right];array[right] = array[left]的写法会导致多个array[index] 重复指向同一个int[] 元素。
// 从而在最后array[left][0/1] = xxx时，导致2个int[] 同时变更为原标记值。
    private int partition(int[][] array, int left, int right) {
        int middleIndex = getMiddleIndex(array, left, (left + right) / 2, right);
        swap(array, left, middleIndex);

        int num = array[left][0];
        int pivot = array[left][1];
        while (left < right) {
            while (left < right && array[right][1] >= pivot) {
                right--;
            }
            
            array[left] = array[right]; //
            
            while (left < right && array[left][1] <= pivot) {
                left++;
            }
            
            array[right] = array[left]; //
        }
        
        array[left][0] = num; //
        array[left][1] = pivot; //
        return left;
    }
```


```java
// 优化写法·正确示例
// 采用值覆盖而非改变指针指向写法，更安全
    private int partition(int[][] array, int left, int right) {
        int middleIndex = getMiddleIndex(array, left, (left + right) / 2, right);
        swap(array, left, middleIndex);

        int num = array[left][0];
        int pivot = array[left][1];
        while (left < right) {
            while (left < right && array[right][1] >= pivot) {
                right--;
            }

            array[left][0] = array[right][0]; // 
            array[left][1] = array[right][1]; //

            while (left < right && array[left][1] <= pivot) {
                left++;
            }

            array[right][0] = array[left][0]; //
            array[right][1] = array[left][1]; //
        }
        array[left][0] = num;                 //
        array[left][1] = pivot;               //
        return left;
    }
```

3.复杂度

    1）时：O(N)--平均时间复杂度O(N),《算法导论》推导出的平均期望；最坏情况下会劣化至O(N*N)
    2）空：O(N)--哈希表O(N) + 堆O(K) = O(N)